import secrets
import select
import sys
from utilities.constants import INPUT_PROMPT, MIN_MENU_ITEM_VALUE, MAX_MENU_ITEM_VALUE, INIT_CLIENT_MSG, \
    INIT_SUCCESS_MSG, MODE_CLIENT
from utilities.init import parse_arguments, generate_keys
from utilities.utility import display_menu, get_user_menu_option, send_message, connect_to_server, receive_data, \
    view_current_connections, close_application


class Client:
    """A class representing the client

    @attention: Design Decision
        Client can only connect to a server and not to other clients
        (i.e., this class does not listen for incoming connections)

    Attributes:
        name - The name of the client
        ip - The ip address
        port - The port number
        own_socket - The socket object for the client
        server_socket - The socket object for the server
        server_name - The name of the server
        pvt_key - The private key generated by ECDH (via. brainpoolP256r1)
        pub_key - The public key generated by ECDH (via. brainpoolP256r1)
        fd_list - A list of file descriptors to monitor (using select() function)
        shared_secret - The shared secret with the server (generated by ECDH key exchange)
        is_connected - A boolean indicating if the client is connected
        terminate - A boolean flag that determines if the server should terminate
    """
    def __init__(self):
        print(INIT_CLIENT_MSG)
        self.name, self.ip, self.port = parse_arguments()
        self.pvt_key, self.pub_key = generate_keys(mode=MODE_CLIENT)
        self.iv = secrets.token_bytes(16)
        self.fd_list = [sys.stdin]  # => Monitored by select()
        self.server_socket, self.server_name = None, None
        self.shared_secret = None
        self.is_connected = False
        self.terminate = False
        print(INIT_SUCCESS_MSG)

    def start(self):
        print("=" * 80)
        display_menu(self.is_connected, is_server=False)
        print(INPUT_PROMPT)

        while not self.terminate:
            readable, _, _ = select.select(self.fd_list, [], [])

            for fd in readable:
                # a) Get User Command from the Menu
                if fd == sys.stdin:
                    command = get_user_menu_option(fd, MIN_MENU_ITEM_VALUE, MAX_MENU_ITEM_VALUE)

                    if command == 1:
                        if self.is_connected and self.server_socket is not None:
                            send_message(self.server_socket, self.shared_secret, self.iv)
                        else:
                            connect_to_server(self)

                    if command == 2:
                        view_current_connections(self)

                    if command == 3:
                        close_application(self)
                        return None

                    display_menu(self.is_connected)
                    print(INPUT_PROMPT)

                # b) Receive data from server socket (fd)
                else:
                    receive_data(self, fd)
