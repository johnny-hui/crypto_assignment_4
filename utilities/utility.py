import hashlib
import ipaddress
import pickle
import socket
from typing import TextIO
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from prettytable import PrettyTable
from tinyec.ec import Inf
from utilities.constants import MENU_TITLE, MENU_FIELD_OPTION, MENU_FIELD_DESC, CLIENT_MENU_OPTIONS_LIST, SEND_MESSAGE_OPTION, \
    SERVER_MENU_OPTIONS_LIST, INVALID_MENU_SELECTION, MENU_ACTION_START_MSG, INVALID_INPUT_MENU_ERROR, MIN_PORT_VALUE, \
    MAX_PORT_VALUE


def derive_shared_secret(pvt_key: int, pub_key):
    """
    Derives the shared secret between a private key
    and another host's public key by performing ECC point
    multiplication

    @param pvt_key:
        An owning host's private key

    @param pub_key:
        The other host's public key

    @return: shared_secret
        The result of pvt_key * pub_key
    """
    return pvt_key * pub_key


def compress(key):
    """
    Compresses a key generated by ECDH key
    exchange protocol into a hex representation
    of 65 hex digits.

    @param key:
        The key to be compressed

    @return: Compressed Key
        A compressed key represented as a hex string
    """
    return hex(key.x) + hex(key.y % 2)[2:]


def compress_shared_secret(shared_secret: Inf):
    """
    Compresses the shared secret (derived from ECDH key exchange)
    into 32 bytes (256 bits) suitable for AES using SHA-256.

    @param shared_secret:
        An Inf object that represents the shared secret

    @return: compressed_key
        A SHA256 hash of the shared secret (32 Bytes)
    """
    # Serialize the coordinates of the shared secret (x, y) into bytes
    serialized_secret_key = shared_secret.x.to_bytes(32, 'big') + shared_secret.y.to_bytes(32, 'big')
    compressed_key = hashlib.sha256(serialized_secret_key).digest()
    return compressed_key


def encrypt(plain_text: bytes, shared_secret: bytes, IV: bytes):
    """
    Uses an AES cipher to encrypt plaintext with a 32-byte
    shared secret key derived from ECDH.

    @param plain_text:
        An array of bytes containing data of the plain text
        to be encrypted

    @param shared_secret:
        Bytes of the shared secret key

    @param IV:
        A randomly generated n-bytes for initialization vector (IV)

    @return: cipher_text
        The encrypted cipher text
    """
    cipher = AES.new(shared_secret, mode=AES.MODE_CBC, iv=IV)
    ciphertext = cipher.encrypt(pad(plain_text, AES.block_size))  # Default padding with PKCS7
    return ciphertext


def decrypt(cipher_text: bytes, shared_secret: bytes, IV: bytes):
    """
    Uses an AES cipher to decrypt ciphertext with a 32-byte
    shared secret key derived from ECDH.

    @param cipher_text:
        An array of bytes containing encrypted data

    @param shared_secret:
        Bytes of the shared secret key

    @param IV:
        An initialization vector for AES cipher

    @return: plain_text
        An array of bytes containing decrypted data
    """
    cipher = AES.new(shared_secret, AES.MODE_CBC, IV)
    plain_text = unpad(cipher.decrypt(cipher_text), AES.block_size)
    return plain_text


def display_menu(is_connected: bool = False, is_server: bool = False):
    """
    Displays the menu for user commands.

    @param is_connected:
        A boolean determining whether a client is connected

    @param is_server:
        A boolean representing whether calling class is Server
        (display server menu options)

    @return: None
    """
    menu = PrettyTable()
    menu.title = MENU_TITLE
    menu.field_names = [MENU_FIELD_OPTION, MENU_FIELD_DESC]

    if is_server:
        for item in SERVER_MENU_OPTIONS_LIST:
            menu.add_row(item)

    if is_connected:
        for item in CLIENT_MENU_OPTIONS_LIST:
            menu.add_row(item)
    else:
        menu.add_row(SEND_MESSAGE_OPTION)
        for item in CLIENT_MENU_OPTIONS_LIST[1:]:
            menu.add_row(item)

    print(menu)


def get_user_menu_option(fd: TextIO, min_num_options: int, max_num_options: int):
    """
    Gets the user selection for the menu.

    @param fd:
        The file descriptor for standard input

    @param min_num_options:
        The minimum number of options possible

    @param max_num_options:
        The maximum number of options possible

    @return: command
        An integer representing the selection
    """
    command = fd.readline().strip()

    try:
        command = int(command)
        while not (min_num_options <= command <= max_num_options):
            print(INVALID_MENU_SELECTION.format(min_num_options, max_num_options))
            command = fd.readline().strip()
        print(MENU_ACTION_START_MSG.format(command))
        return command
    except ValueError as e:
        print(INVALID_INPUT_MENU_ERROR.format(e))
        print(INVALID_MENU_SELECTION.format(min_num_options, max_num_options))
    except TypeError as e:
        print(INVALID_INPUT_MENU_ERROR.format(e))
        print(INVALID_MENU_SELECTION.format(min_num_options, max_num_options))


def __get_target_ip():
    """
    A helper function that gets the target IP address
    from user prompt.

    @raise ValueError
        Exception raised if the target IP address is invalid

    @return: ip_address
        A string representing the target IP address
    """
    while True:
        try:
            ip_input = input("[+] Enter the IP address of the target server: ")
            ip_address = str(ipaddress.ip_address(ip_input))
            return ip_address
        except ValueError:
            print("[+] Invalid IP address; please enter again.\n")


def __get_target_port():
    """
    A helper function that gets the target port
    from user prompt.

    @raise ValueError:
        Exception raised if the target port is of invalid format

    @raise TypeError:
        Exception raised if the user inputs not an integer value

    @return: port
        An integer representing the target port
    """
    while True:
        try:
            port = int(input("\n[+] Enter the port number of the target server: "))
            while port not in range(MIN_PORT_VALUE, MAX_PORT_VALUE):
                print("[+] Invalid port number range; please enter again.")
                port = int(input("\n[+] Enter the port number of the target server: "))
            return port
        except ValueError as e:
            print("[+] Invalid port number ({}); please enter again.".format(e))
        except TypeError as e:
            print("[+] Invalid port number ({}); please enter again.".format(e))


def connect_to_server(self: object):
    """
    Prompts the user for the target IP address and port, and
    connects to the target using sockets.

    @raise socket.error
        Exception raised if the target host is offline or
        incorrect host information

    @param self:
        The calling object

    @return: None
    """
    target_ip = __get_target_ip()
    target_port = __get_target_port()

    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((target_ip, target_port))
        print(f"[+] CONNECTION EVENT: Established a connection to server! ({target_ip}, {target_port})")
        print("[+] KEY EXCHANGE: Now exchanging keys with the server...")

        # Bind class attributes
        self.is_connected = True
        self.server_socket = sock
        self.sockets.append(sock)

        # Send Public Key to Server
        serialized_key = pickle.dumps(self.pub_key)
        sock.sendall(serialized_key)

        # Receive Public Key from Server
        serialized_server_pub_key = sock.recv(4096)
        server_pub_key = pickle.loads(serialized_server_pub_key)

        # Send initialization vector (IV) to server
        sock.send(self.iv)

        # Derive the shared secret
        shared_secret = derive_shared_secret(self.pvt_key, server_pub_key)
        self.shared_secret = compress_shared_secret(shared_secret)
        print(f"[+] KEY EXCHANGE SUCCESS: A shared secret has been derived for the current "
              f"session ({compress(shared_secret)})!")

        # Wait for signal to send name
        sock.recv(1024)
        sock.send(encrypt(self.name.encode('utf-8'), self.shared_secret, self.iv))

    except socket.error as e:
        print("[+] CONNECTION FAILED: Failed to connect to target server ({}); please try again.".format(e))


def exchange_public_keys(pub_key: Inf, client_sock: socket.socket):
    """
    Performs the ECDH public key exchange process.

    @param pub_key:
        The public key to send over

    @param client_sock:
        The client's socket

    @return: client_pub_key
    """
    print("[+] KEY EXCHANGE: Now exchanging keys with new client...")

    # Receive Client's Public Key
    serialized_client_pub_key = client_sock.recv(4096)
    client_pub_key = pickle.loads(serialized_client_pub_key)

    # Send over the public key to the client
    serialized_key = pickle.dumps(pub_key)
    client_sock.sendall(serialized_key)
    return client_pub_key


def accept_new_connection_handler(pvt_key: int, pub_key: Inf, own_sock: socket.socket,
                                  sockets: list[socket], client_dict: dict):
    """
    A server handler to accept a new client connection, which
    involves the ECDH public key exchange process and generation
    of shared secret with the client.

    @param pvt_key:
        The calling class's private key (Server)

    @param pub_key:
        The calling class's public key (Server)

    @param own_sock:
        The socket object of the calling class

    @param sockets:
        A list of sockets

    @param client_dict:
        A dictionary containing client information

    @return: None
    """
    client_socket, client_address = own_sock.accept()
    print(f"[+] NEW CONNECTION: Accepted a client connection from ({client_address[0]}, {client_address[1]})!")

    # Exchange public keys with the client
    sockets.append(client_socket)
    client_pub_key = exchange_public_keys(pub_key, client_socket)

    # Receive IV from the client
    client_iv = client_socket.recv(1024)

    # Derive the shared secret and compress for AES
    shared_secret = derive_shared_secret(pvt_key, client_pub_key)
    compressed_shared_secret = compress_shared_secret(shared_secret)
    print(f"[+] KEY EXCHANGE SUCCESS: A shared secret has been derived for the current "
          f"session ({compress(shared_secret)})!")

    # Send signal to get the name of client
    client_socket.send(encrypt(b"ACK", compressed_shared_secret, client_iv))

    # Receive name from the client (encrypted)
    name = decrypt(client_socket.recv(1024), compressed_shared_secret, client_iv).decode()

    # Update client dictionary with the new client
    client_dict[client_address[0]] = [name, compressed_shared_secret, client_iv]
    print(f"[+] CONNECTION SUCCESS: New client has been added ({name}: [{client_address[0]}, {client_address[1]}])!")


def send_message(sock: socket.socket):
    print("PLACEHOLDER")
