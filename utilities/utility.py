import hashlib
import ipaddress
import pickle
import socket
from typing import TextIO
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from prettytable import PrettyTable
from tinyec.ec import Inf
from utilities.constants import (MENU_TITLE, MENU_FIELD_OPTION, MENU_FIELD_DESC, CLIENT_MENU_OPTIONS_LIST,
                                 SEND_MESSAGE_OPTION, SERVER_MENU_OPTIONS_LIST, INVALID_MENU_SELECTION,
                                 MENU_ACTION_START_MSG, INVALID_INPUT_MENU_ERROR, MIN_PORT_VALUE,
                                 MAX_PORT_VALUE, CONNECTION_INFO_FIELD_NAME, CONNECTION_INFO_FIELD_IP,
                                 CONNECTION_INFO_FIELD_SECRET, CONNECTION_INFO_FIELD_IV)


def derive_shared_secret(pvt_key: int, pub_key):
    """
    Derives the shared secret between a private key
    and another host's public key by performing ECC point
    multiplication

    @param pvt_key:
        An owning host's private key

    @param pub_key:
        The other host's public key

    @return: shared_secret
        The result of pvt_key * pub_key
    """
    return pvt_key * pub_key


def compress(key):
    """
    Compresses a key generated by ECDH key
    exchange protocol into a hex representation
    of 65 hex digits.

    @param key:
        The key to be compressed

    @return: Compressed Key
        A compressed key represented as a hex string
    """
    return hex(key.x) + hex(key.y % 2)[2:]


def compress_shared_secret(shared_secret: Inf):
    """
    Compresses the shared secret (derived from ECDH key exchange)
    into 32 bytes (256 bits) suitable for AES using SHA-256.

    @param shared_secret:
        An Inf object that represents the shared secret

    @return: compressed_key
        A SHA256 hash of the shared secret (32 Bytes)
    """
    # Serialize the coordinates of the shared secret (x, y) into bytes
    serialized_secret_key = shared_secret.x.to_bytes(32, 'big') + shared_secret.y.to_bytes(32, 'big')
    compressed_key = hashlib.sha256(serialized_secret_key).digest()
    return compressed_key


def encrypt(plain_text: bytes, shared_secret: bytes, IV: bytes):
    """
    Uses an AES cipher to encrypt plaintext with a 32-byte
    shared secret key derived from ECDH.

    @param plain_text:
        An array of bytes containing data of the plain text
        to be encrypted

    @param shared_secret:
        Bytes of the shared secret key

    @param IV:
        A randomly generated n-bytes for initialization vector (IV)

    @return: cipher_text
        The encrypted cipher text
    """
    cipher = AES.new(shared_secret, mode=AES.MODE_CBC, iv=IV)
    ciphertext = cipher.encrypt(pad(plain_text, AES.block_size))  # Default padding with PKCS7
    return ciphertext


def decrypt(cipher_text: bytes, shared_secret: bytes, IV: bytes):
    """
    Uses an AES cipher to decrypt ciphertext with a 32-byte
    shared secret key derived from ECDH.

    @param cipher_text:
        An array of bytes containing encrypted data

    @param shared_secret:
        Bytes of the shared secret key

    @param IV:
        An initialization vector for AES cipher

    @return: plain_text
        An array of bytes containing decrypted data
    """
    cipher = AES.new(shared_secret, AES.MODE_CBC, IV)
    plain_text = unpad(cipher.decrypt(cipher_text), AES.block_size)
    return plain_text


def display_menu(is_connected: bool = False, is_server: bool = False):
    """
    Displays the menu for user commands.

    @param is_connected:
        A boolean determining whether a client is connected

    @param is_server:
        A boolean representing whether calling class is Server
        (display server menu options)

    @return: None
    """
    menu = PrettyTable()
    menu.title = MENU_TITLE
    menu.field_names = [MENU_FIELD_OPTION, MENU_FIELD_DESC]

    if is_server:
        for item in SERVER_MENU_OPTIONS_LIST:
            menu.add_row(item)
    elif is_connected:
        menu.add_row(SEND_MESSAGE_OPTION)
        for item in CLIENT_MENU_OPTIONS_LIST[1:]:
            menu.add_row(item)
    else:
        for item in CLIENT_MENU_OPTIONS_LIST:
            menu.add_row(item)

    print(menu)


def view_current_connections(self: object, is_server: bool = False):
    """
    Displays information of all current connections.

    @param self:
        A reference to the calling class object

    @param is_server:
        A boolean to determine if calling class is a
        server (default = False)

    @return: None
    """
    if len(self.fd_list) > 1:
        table = PrettyTable()  # => Instantiate table and fill with data
        table.field_names = [CONNECTION_INFO_FIELD_NAME, CONNECTION_INFO_FIELD_IP,
                             CONNECTION_INFO_FIELD_SECRET, CONNECTION_INFO_FIELD_IV]

        if is_server:
            for ip, information in self.client_dict.items():  # Format {ip: information = [name, shared_secret, IV]}
                table.add_row([information[0], ip, information[1], information[2]])
        else:
            table.add_row([self.server_name, self.server_socket.getpeername()[0], self.shared_secret, self.iv])

        print(table)
    else:
        print("[+] VIEW CURRENT CONNECTIONS: There are no current connections to view!")


def close_application(self: object, is_server: bool = False):
    """
    Terminates the application.

    @param self:
        A reference to the calling class object

    @param is_server:
        A boolean to determine if calling class is a
        server (default = False)

    @return: None
    """
    print("[+] CLOSE APPLICATION: Now closing the application...")
    for fd in self.fd_list:
        fd.close()
    self.terminate = True
    print("[+] Application has been terminated!")


def get_user_menu_option(fd: TextIO, min_num_options: int, max_num_options: int):
    """
    Gets the user selection for the menu.

    @param fd:
        The file descriptor for standard input

    @param min_num_options:
        The minimum number of options possible

    @param max_num_options:
        The maximum number of options possible

    @return: command
        An integer representing the selection
    """
    command = fd.readline().strip()

    try:
        command = int(command)
        while not (min_num_options <= command <= max_num_options):
            print(INVALID_MENU_SELECTION.format(min_num_options, max_num_options))
            command = fd.readline().strip()
        print(MENU_ACTION_START_MSG.format(command))
        return command
    except ValueError as e:
        print(INVALID_INPUT_MENU_ERROR.format(e))
        print(INVALID_MENU_SELECTION.format(min_num_options, max_num_options))
    except TypeError as e:
        print(INVALID_INPUT_MENU_ERROR.format(e))
        print(INVALID_MENU_SELECTION.format(min_num_options, max_num_options))


def __get_target_ip():
    """
    A helper function that gets the target IP address
    from user prompt.

    @raise ValueError
        Exception raised if the target IP address is invalid

    @return: ip_address
        A string representing the target IP address
    """
    while True:
        try:
            ip_input = input("[+] Enter the IP address of the target server: ")
            ip_address = str(ipaddress.ip_address(ip_input))
            return ip_address
        except ValueError:
            print("[+] Invalid IP address; please enter again.\n")


def __get_target_port():
    """
    A helper function that gets the target port
    from user prompt.

    @raise ValueError:
        Exception raised if the target port is of invalid format

    @raise TypeError:
        Exception raised if the user inputs not an integer value

    @return: port
        An integer representing the target port
    """
    while True:
        try:
            port = int(input("\n[+] Enter the port number of the target server: "))
            while port not in range(MIN_PORT_VALUE, MAX_PORT_VALUE):
                print("[+] Invalid port number range; please enter again.")
                port = int(input("\n[+] Enter the port number of the target server: "))
            return port
        except ValueError as e:
            print(f"[+] Invalid port number ({e}); please enter again.")
        except TypeError as e:
            print(f"[+] Invalid port number ({e}); please enter again.")


def connect_to_server(self: object):
    """
    Prompts the user for the target IP address and port, and
    connects to the target using sockets.

    @raise socket.error
        Exception raised if the target host is offline or
        incorrect host information

    @param self:
        The calling object

    @return: None
    """
    target_ip = __get_target_ip()
    target_port = __get_target_port()

    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((target_ip, target_port))
        print(f"[+] CONNECTION EVENT: Established a connection to server! ({target_ip}, {target_port})")
        print("[+] KEY EXCHANGE: Now exchanging keys with the server...")

        # Bind class attributes
        self.is_connected = True
        self.server_socket = sock
        self.fd_list.append(sock)

        # Send Public Key to Server
        serialized_key = pickle.dumps(self.pub_key)
        sock.sendall(serialized_key)

        # Receive Public Key from Server
        serialized_server_pub_key = sock.recv(4096)
        server_pub_key = pickle.loads(serialized_server_pub_key)

        # Send initialization vector (IV) to server
        sock.send(self.iv)

        # Derive the shared secret
        shared_secret = derive_shared_secret(self.pvt_key, server_pub_key)
        self.shared_secret = compress_shared_secret(shared_secret)
        print(f"[+] KEY EXCHANGE SUCCESS: A shared secret has been derived for the current "
              f"session ({hex(shared_secret)})!")

        # Receive name of server and send own name
        self.server_name = decrypt(sock.recv(1024), self.shared_secret, self.iv).decode('utf-8')
        sock.send(encrypt(self.name.encode('utf-8'), self.shared_secret, self.iv))
        print(f"[+] CONNECTION SUCCESS: A secure session with {self.server_name} has been established!")
    except socket.error as e:
        print(f"[+] CONNECTION FAILED: Failed to connect to target server ({e}); please try again.")


def exchange_public_keys(pub_key: Inf, client_sock: socket.socket):
    """
    Performs the ECDH public key exchange process.

    @param pub_key:
        The public key to send over

    @param client_sock:
        The client's socket

    @return: client_pub_key
    """
    print("[+] KEY EXCHANGE: Now exchanging keys with new client...")

    # Receive Client's Public Key
    serialized_client_pub_key = client_sock.recv(4096)
    client_pub_key = pickle.loads(serialized_client_pub_key)

    # Send over the public key to the client
    serialized_key = pickle.dumps(pub_key)
    client_sock.sendall(serialized_key)
    return client_pub_key


def accept_new_connection_handler(self: object, own_sock: socket.socket):
    """
    A handler to accept a new client connection, which
    involves the ECDH public key exchange process and generation
    of shared secret with the client.

    @param self:
        A reference to the calling class object (Server)

    @param own_sock:
        The socket object of the calling class (Server)

    @return: None
    """
    client_socket, client_address = own_sock.accept()
    print(f"[+] NEW CONNECTION: Accepted a client connection from ({client_address[0]}, {client_address[1]})!")

    # Exchange public keys with the client
    self.fd_list.append(client_socket)
    client_pub_key = exchange_public_keys(self.pub_key, client_socket)

    # Receive IV from the client
    client_iv = client_socket.recv(1024)

    # Derive the shared secret and compress for AES
    shared_secret = derive_shared_secret(self.pvt_key, client_pub_key)
    compressed_shared_secret = compress_shared_secret(shared_secret)
    print(f"[+] KEY EXCHANGE SUCCESS: A shared secret has been derived for the current "
          f"session ({hex(shared_secret)})!")

    # Send signal to prevent hanging
    client_socket.send(encrypt(self.name.encode(), compressed_shared_secret, client_iv))

    # Receive name from the client (encrypted)
    name = decrypt(client_socket.recv(1024), compressed_shared_secret, client_iv).decode()

    # Update client dictionary with the new client
    self.client_dict[client_address[0]] = [name, compressed_shared_secret, client_iv]
    print(f"[+] CONNECTION SUCCESS: A secure session has been established!")


def send_message(sock: socket.socket, shared_secret: bytes, IV: bytes):
    """
    Prompts user for a plaintext message, encrypts it
    and send it to a target socket.

    @param sock:
        The target socket

    @param shared_secret:
        Bytes of the shared secret key

    @param IV:
        A randomly generated n-bytes for initialization vector (IV)

    @return: None
    """
    message = input("[+] Enter a message to send: ").encode()
    cipher_text = encrypt(message, shared_secret, IV)
    sock.send(cipher_text)
    print("[+] Your message has been successfully sent!")


def receive_data(self: object, sock: socket.socket, is_server: bool = False):
    """
    Handles the receiving of data (or disconnections) from a socket.

    @param self:
        A reference to the calling class object

    @param sock:
        A socket object

    @param is_server:
        A boolean to determine if calling class is a
        server (default = False)

    @return: None
    """
    # Get address and data from the corresponding socket
    ip_address, _ = sock.getpeername()
    data = sock.recv(1024)

    # Handler for Server
    if is_server:
        client_info = self.client_dict[ip_address]  # => Get specific client secret {IP: [name, shared_secret, IV]}
        if data:
            print(f"[+] Received data from [{client_info[0]}, {ip_address}] (encrypted): {data.decode()}")
            plain_text = decrypt(data, client_info[1], client_info[2])
            print(f"[+] Received data from [{client_info[0]}, {ip_address}] (decrypted): {plain_text.decode()}")
        else:
            print(f"[+] Connection closed by ({client_info[0]}, {ip_address})")
            del self.client_dict[ip_address]
            self.fd_list.remove(sock)
            sock.close()

    # Handler for Client
    else:
        if data:
            print(f"[+] Received data from [{self.server_name}, {ip_address}] (encrypted): {data.decode()}")
            plain_text = decrypt(data, self.shared_secret, self.iv)
            print(f"[+] Received data from [{self.server_name}, {ip_address}] (decrypted): {plain_text.decode()}")
        else:
            print(f"[+] Connection closed by ({self.server_name}, {ip_address})")
            self.server_socket = None
            self.server_name = None
            self.shared_secret = None
            self.fd_list.remove(sock)
            sock.close()
